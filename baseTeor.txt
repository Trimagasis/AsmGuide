1Первый пункт1
@2@Первый подпункт2
@3@Первый подподпункт3
@3@Второй подподпункт3
@3@Третий подподпункт3
@3@Четвертый подподпункт3
@3@Пятый подподпункт3
@2@Второй подпункт2
@2@Третий подпункт2
@1@Второй пункт1
@2@Первый подпункт2
@2@Второй подпункт2
@1@Третий пункт1
%

Арифметические команды в ассемблере


&	Сложение

ADD – команда для сложения двух чисел. Она работает как с числами со знаком, так и без знака.

	ADD Приемник, Источник

Логика работы команды:

	<Приемник> = <Приемник> + <Источник>

Возможные сочетания операндов для этой команды аналогичны команде MOV.

Операнды должны иметь одинаковый размер. Результат помещается на место первого операнда.&


&	Вычитание

SUB - команда для вычитания одного числа из другого. Она работает как с числами со знаком, так и без знака.

	SUB Приемник, Источник

Логика работы команды:

	<Приемник> = <Приемник> - <Источник>

Возможные сочетания операндов для этой команды аналогичны команде MOV.

Операнды должны иметь одинаковый размер. Результат помещается на место первого операнда.

На самом деле вычитание в процессоре реализовано с помощью сложения. 
Процессор меняет знак второго операнда на противоположный, а затем складывает два числа.&


&	Умножение

MUL – команда умножения чисел без знака. У этой команды только один операнд — второй множитель, 
который должен находиться в регистре или в памяти. Местоположение первого множителя и результата 
задаётся неявно и зависит от размера операнда:

 -------------------------------------------
 | Размер операнда | Множитель | Результат |
 | 		   |           |	   |
 |      1 байт 	   |     AL    |    AX	   |
 | 		   |	       |	   |
 |      2 байта    |     AX    |   DX:AX   |
 | 		   |	       |	   |
 |      4 байта    |    EAX    |  EDX:EAX  |
 -------------------------------------------

Отличие умножения от сложения и вычитания в том, что разрядность результата получается 
в 2 раза больше, чем разрядность сомножителей.

IMUL – команда умножения чисел со знаком. Эта команда имеет три формы, различающиеся 
количеством операндов:

1. С одним операндом — форма, аналогичная команде MUL. В качестве операнда указывается множитель. 
	Местоположение другого множителя и результата определяется по таблице.

2. С двумя операндами — указываются два множителя. Результат записывается на место первого множителя. 
	Старшая часть результата в этом случае игнорируется. 
	Кстати, эта форма команды не работает с операндами размером 1 байт.

3. С тремя операндами — указывается положение результата, первого и второго множителя. 
	Второй множитель должен быть непосредственным значением. 
	Результат имеет такой же размер, как первый множитель, старшая часть результата игнорируется. 
	Это форма тоже не работает с однобайтными множителями.&


&	Деление

DIV – команда деления чисел без знака. У этой команды один операнд — делитель, 
	который должен находиться в регистре или в памяти. 
	Местоположение делимого, частного и остатка задаётся неявно и зависит от размера операнда:

------------------------------------------------------------
| Размер операнда (делителя) | Делимое | Частное | Остаток |
| 			     |	       |         |	   |
|      1 байт 	             |    AX   |    AL   |    AH   |
| 		 	     |	       |	 |         |
|      2 байта    	     |  DX:AX  |    AX   |    DX   |
| 		 	     |	       |	 |         |
|      4 байта    	     | EDX:EAX |   EAX   |   EDX   |
------------------------------------------------------------

При выполнении команды DIV может возникнуть прерывание 
(в данном курсе прерывания мы рассматривать не будем поэтому старайтесь избегать таких случаев):

	· если делитель равен нулю;

	· если частное не помещается в отведённую под него разрядную сетку 
	(например, если при делении слова на байт частное больше 255).

IDIV – команда деления чисел со знаком. Единственным операндом является делитель. 
Местоположение делимого и частного определяется также, как для команды DIV. 
Эта команда тоже генерирует прерывание при делении на ноль или слишком большом частном.&



Команды переходов


&	Безусловный переход

Команда безусловного перехода имеет следующий синтаксис:

	JMP <операнд>

Операнд указывает адрес перехода. Существует два способа указания этого адреса, 
соответственно различают прямой и косвенный переходы.&


&	Прямой переход

Если в команде перехода указывается метка команды, на которую надо перейти, 
то переход называется прямым.&


&	Косвенный переход

При косвенном переходе в команде перехода указывается не адрес перехода, а регистр или ячейка памяти, 
где этот адрес находится. Содержимое указанного регистра или ячейки памяти рассматривается 
как абсолютный адрес перехода. Косвенные переходы используются в тех случаях, 
когда адрес перехода становится известен только во время работы программы.&



Работа с массивами


&	Определение

Массив - структурированный тип данных, состоящий из некоторого числа элементов одного типа.&


&	Описание и инициализация массива в программе

Специальных средств описания массивов в программах ассемблера, конечно, нет. 
При необходимости использовать массив в программе его нужно моделировать одним из следующих способов: 
	
1) Перечислением элементов массива в поле операндов одной из директив описания данных. 
	При перечислении элементы разделяются запятыми.

2) Используя оператор повторения dup. Такой способ определения используется для резервирования памяти 
	с целью размещения и инициализации элементов массива.

3) Используя директивы label и rept. Пара этих директив может облегчить описание больших массивов в памяти 
	и повысить наглядность такого описания. 
	Директива rept относится к макросредствам языка ассемблера и вызывает повторение указанное число раз строк, 
	заключенных между директивой и строкой endm.

4) Использование цикла для инициализации значениями области памяти, 
	которую можно будет впоследствии трактовать как массив.&


&	Доступ к элементам массива

При работе с массивами необходимо четко представлять себе, что все элементы массива располагаются в памяти 
компьютера последовательно. Само по себе такое расположение ничего не говорит о назначении и порядке 
использования этих элементов. И только лишь программист с помощью составленного им алгоритма обработки 
определяет, как нужно трактовать эту последовательность байт, составляющих массив. 
Так, одну и ту же область памяти можно трактовать как одномерный массив, и одновременно те же самые данные 
могут трактоваться как двухмерный массив. Все зависит только от алгоритма обработки этих данных в 
конкретной программе. Сами по себе данные не несут никакой информации о своем “смысловом”, или логическом, типе.

Эти же соображения можно распространить и на индексы элементов массива. 
Ассемблер не подозревает об их существовании и ему абсолютно все равно, каковы их численные смысловые значения.

Для того чтобы локализовать определенный элемент массива, к его имени нужно добавить индекс. 
Так как мы моделируем массив, то должны позаботиться и о моделировании индекса. 
В языке ассемблера индексы массивов — это обычные адреса, но с ними работают особым образом. 
Другими словами, когда при программировании на ассемблере мы говорим об индексе, 
то скорее подразумеваем под этим не номер элемента в массиве, а некоторый адрес.&


&	Двухмерные массивы

Двухмерный массив нужно моделировать. На описании самих данных это почти никак не отражается — память под массив 
выделяется с помощью директив резервирования и инициализации памяти. Непосредственно моделирование обработки 
массива производится в сегменте кода, где программист, описывая алгоритм обработки ассемблеру, определяет, 
что некоторую область памяти необходимо трактовать как двухмерный массив. При этом вы вольны в выборе того, 
как понимать расположение элементов двухмерного массива в памяти: по строкам или по столбцам. 
Если последовательность однотипных элементов в памяти трактуется как двухмерный массив, расположенный по строкам, 
то адрес элемента (i, j) вычисляется по формуле (база + количество_элементов_в_строке * размер_элемента * i+j) 
Здесь i = 0...n–1 указывает номер строки, а j = 0...m–1 указывает номер столбца.&



Работа со стеком в ассемблере


&	Команды работы со стеком

В процессорах Intel команду BSWAP можно использовать и для обращения порядка байт в 16-битных регистрах, 
но в некоторых совместимых процессорах других фирм этот вариант BSWAP не реализован.

	Команда: PUSH источник

	Назначение: Поместить данные в стек

	Процессор: 8086

Команда помещает содержимое источника в стек. В качестве параметра «источник» может быть регистр, 
сегментный регистр, непосредственный операнд или переменная. Фактически эта команда копирует содержимое источника 
в память по адресу SS:[ESP] и уменьшает ESP на размер источника в байтах (2 или 4). 
Команда PUSH практически всегда используется в паре с POP (считать данные из стека).

Другое частое применение команд PUSH/POP — временное хранение переменных.

Начиная с 80286, команда PUSH ESP (или SP) помещает в стек значение ESP до того, как эта же команда его уменьшит, 
в то время как на 8086 SP помещался в стек уже уменьшенным на два.

Команда помещает в приемник слово или двойное слово, находящееся в вершине стека, 
увеличивая ESP на 2 или 4 соответственно. POP выполняет действие, полностью обратное PUSH. 
Приемником может быть регистр общего назначения, сегментный регистр, 
кроме CS (чтобы загрузить CS из стека, надо воспользоваться командой RET), или переменная. 
Если в роли приемника выступает операнд, использующий ESP для косвенной адресации, 
команда POP вычисляет адрес операнда уже после того, как она увеличивает ESP.

PUSHA помещает в стек регистры в следующем порядке: АХ, СХ, DX, ВХ, SP, ВР, SI и DI. 
PUSHAD помещает в стек ЕАХ, ЕСХ, EDX, ЕВХ, ESP, EBP, ESI и EDI. В паре с командами POPA/POPAD, 
считывающими эти же регистры из стека в обратном порядке, это позволяет писать подпрограммы, 
которые не должны изменять значения регистров по окончании своей работы. 
В начале такой подпрограммы вызывают команду PUSHA, а в конце — РОРА.

В паре с командами POPA/POPAD, считывающими эти же регистры из стека в обратном порядке, 
это позволяет писать подпрограммы (обычно обработчики прерываний), которые не должны изменять значения регистров 
по окончании своей работы. В начале такой подпрограммы вызывают команду PUSHA, а в конце — РОРА.

Это же будет распространяться на некоторые другие пары команд: 
РОРА/POPAD, POPF/POPFD, PUSHF/PUSHFD, JCXZ/JECXZ, CMPSW/CMPSD, INSW/INSD, 
LODSW/LODSD, MOVSW/MOVSD, OUTSW/OUTSD, SCASW/SCASD и STOSW/STOSD.&


&	Передача параметров в стеке

Параметры помещаются в стек сразу перед вызовом процедуры. 
Именно этот метод используют языки высокого уровня, такие как С и Pascal. 
Для чтения параметров из стека обычно используют не команду POP, а регистр ВР, 
в который помещают адрес вершины стека после входа в процедуру.

Параметры в стеке, адрес возврата и старое значение ВР вместе называются активационной записью функции.

Для удобства ссылок на параметры, переданные в стеке, внутри функции иногда используют директивы EQU, 
чтобы не писать каждый раз точное смещение параметра от начала активационной записи (то есть от ВР).&


&	Передача параметров в потоке кода

В этом необычном методе передаваемые процедуре данные размещаются прямо в коде программы, 
сразу после команды CALL 
(как реализована процедура print в одной из стандартных библиотек процедур для ассемблера UCRLIB).

Чтобы прочитать параметр, процедура должна использовать его адрес, который автоматически передается в стеке 
как адрес возврата из процедуры. Разумеется, функция должна будет изменить адрес возврата на 
первый байт после конца переданных параметров перед выполнением команды RET.

Передача параметров в потоке кода, так же, как и передача параметров в стеке в обратном порядке (справа налево), 
позволяет передавать различное число параметров. Но этот метод - единственный, позволяющий передать по значению 
параметр различной длины, что и продемонстрировал этот пример. Доступ к параметрам, переданным в потоке кода, 
несколько медленнее, чем к параметрам, переданным в регистрах, глобальных переменных или стеке, 
и примерно совпадает со следующим методом.&